import logging
import json
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional

from app import config # For FEEDBACK_LOG_FILE and FEEDBACK_LOG_LEVEL

# --- Feedback Logger Setup ---
# Use a distinct logger name to avoid interfering with general app logging if needed.
FEEDBACK_LOGGER_NAME = "InteractionFeedbackLogger"
feedback_logger = logging.getLogger(FEEDBACK_LOGGER_NAME)

# Flag to ensure setup happens only once
_feedback_logger_initialized = False

def setup_feedback_logger():
    """
    Configures the feedback logger to write structured interaction data to a dedicated file.
    This should be called once at application startup.
    """
    global _feedback_logger_initialized
    if _feedback_logger_initialized:
        return

    feedback_logger.setLevel(config.FEEDBACK_LOG_LEVEL)

    # Prevent feedback logs from propagating to the root logger,
    # if we want them to be exclusively in the feedback file.
    feedback_logger.propagate = False

    # Create file handler
    # Ensure FEEDBACK_LOG_FILE path is absolute or correctly relative to project root
    # For simplicity, config.py should make it absolute if needed.
    # Here, we assume config.FEEDBACK_LOG_FILE is the intended final path.
    try:
        log_file_path = config.PROJECT_ROOT / config.FEEDBACK_LOG_FILE
        file_handler = logging.FileHandler(log_file_path)
    except Exception as e:
        # Fallback or error if path in config is problematic
        logging.getLogger(__name__).error(f"Failed to create FileHandler for feedback log at {config.PROJECT_ROOT / config.FEEDBACK_LOG_FILE}: {e}", exc_info=True)
        # Potentially fallback to a default local file name or disable file logging for feedback
        try:
            fallback_path = config.PROJECT_ROOT / "fallback_interaction_feedback.log"
            logging.getLogger(__name__).warning(f"Attempting to use fallback feedback log path: {fallback_path}")
            file_handler = logging.FileHandler(fallback_path)
        except Exception as fallback_e:
            logging.getLogger(__name__).error(f"Failed to create fallback FileHandler for feedback log: {fallback_e}", exc_info=True)
            _feedback_logger_initialized = True # Mark as initialized to prevent re-attempts, even if failed
            return


    # Create a formatter that outputs the message directly (as it will be JSON)
    # Each log record's message will be a JSON string.
    formatter = logging.Formatter('%(message)s')
    file_handler.setFormatter(formatter)

    # Add handler to the feedback logger
    if not feedback_logger.handlers: # Add handler only if no handlers are already configured
        feedback_logger.addHandler(file_handler)

    feedback_logger.info(f"Interaction feedback logger initialized. Logging to: {log_file_path if 'log_file_path' in locals() else 'fallback path or failed'}")
    _feedback_logger_initialized = True


def log_interaction(
    session_id: str,
    user_query: str,
    retrieved_context_summary: List[Dict[str, Any]],
    llm_response: str,
    was_helpful: Optional[bool] = None,
    corrected_answer: Optional[str] = None,
    # Add other relevant fields as needed, e.g., query_embedding_model, llm_model_used
) -> None:
    """
    Logs a single query-response interaction cycle along with feedback placeholders.

    Args:
        session_id: The ID of the conversation session.
        user_query: The query submitted by the user.
        retrieved_context_summary: A summary of the context chunks retrieved.
                                   Example: [{"doc_id": "path/to/doc1", "distance": 0.5}, ...]
        llm_response: The response generated by the LLM.
        was_helpful: Placeholder for explicit user feedback (boolean).
        corrected_answer: Placeholder for explicit user correction (string).
    """
    if not _feedback_logger_initialized:
        # This is a fallback if setup wasn't called or failed.
        # It won't log to file but will prevent crashes.
        # A more robust solution might try to re-initialize or log to a default console.
        logging.getLogger(__name__).error("Feedback logger was not initialized. Cannot log interaction.")
        # Attempt one-time setup, could be risky if config isn't fully loaded yet
        # setup_feedback_logger()
        # if not _feedback_logger_initialized: return
        return


    timestamp = datetime.now(timezone.utc).isoformat()

    log_entry = {
        "timestamp": timestamp,
        "session_id": session_id,
        "user_query": user_query,
        "retrieved_context_summary": retrieved_context_summary,
        "llm_response": llm_response,
        "feedback": {
            "was_helpful": was_helpful,
            "corrected_answer": corrected_answer,
        }
        # "llm_model_used": config.LLM_MODEL_NAME # Example of adding more metadata
    }

    try:
        feedback_logger.info(json.dumps(log_entry))
    except Exception as e:
        # Fallback logging if JSON serialization fails or other logging issue
        logging.getLogger(__name__).error(f"Failed to log interaction for session {session_id} to feedback log: {e}", exc_info=True)
        # Optionally, log the raw data to the main app log as a fallback:
        # logging.getLogger(__name__).error(f"Raw interaction data: {log_entry}")


if __name__ == "__main__":
    # This block is for testing the feedback_logger module itself.
    # It requires app.config to be available or mocked.

    # Basic logging setup for this test script
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    logger.info("--- Testing Feedback Logger ---")

    # Mock config if not running within the full app context
    if not hasattr(config, 'FEEDBACK_LOG_FILE'):
        config.FEEDBACK_LOG_FILE = "test_interaction_feedback.log"
        config.PROJECT_ROOT = Path(".") # Assume current dir is project root for test
        config.FEEDBACK_LOG_LEVEL = "DEBUG"
        logger.info(f"Mocked config: FEEDBACK_LOG_FILE={config.PROJECT_ROOT / config.FEEDBACK_LOG_FILE}, LEVEL={config.FEEDBACK_LOG_LEVEL}")

    # Ensure the log file from previous test runs is cleared for a clean test
    test_log_path = config.PROJECT_ROOT / config.FEEDBACK_LOG_FILE
    if test_log_path.exists():
        try:
            test_log_path.unlink()
            logger.info(f"Removed old test log file: {test_log_path}")
        except OSError as e:
            logger.error(f"Error removing old test log file {test_log_path}: {e}")


    # Setup the feedback logger
    setup_feedback_logger()
    if not _feedback_logger_initialized or not feedback_logger.handlers:
        logger.error("Feedback logger failed to initialize properly in test. Exiting test.")
        exit()
    logger.info(f"Feedback logger name: {feedback_logger.name}")
    logger.info(f"Feedback logger level: {logging.getLevelName(feedback_logger.level)}")
    logger.info(f"Feedback logger handlers: {feedback_logger.handlers}")
    logger.info(f"Feedback logger propagate: {feedback_logger.propagate}")


    # Log some sample interactions
    log_interaction(
        session_id="session_001",
        user_query="How do I reset my VPN password?",
        retrieved_context_summary=[
            {"doc_id": "vpn_guide.md", "distance": 0.34, "metadata_source": "vpn_docs"},
            {"doc_id": "password_policy.pdf", "distance": 0.55, "metadata_source": "hr_policy"}
        ],
        llm_response="To reset your VPN password, please follow steps X, Y, Z.",
        was_helpful=True
    )

    log_interaction(
        session_id="session_002",
        user_query="My printer is not working.",
        retrieved_context_summary=[
            {"doc_id": "printer_troubleshooting.doc", "distance": 0.22, "metadata_source": "it_kb"}
        ],
        llm_response="Could you provide the printer model and any error messages?",
        was_helpful=None,
        corrected_answer="The actual solution was to restart the print spooler."
    )

    log_interaction(
        session_id="session_001", # Continue session 1
        user_query="Thanks, that worked!",
        retrieved_context_summary=[], # No context needed for a thank you
        llm_response="You're welcome! Glad I could help.",
    )

    logger.info(f"Test interactions logged. Please check the file: {config.PROJECT_ROOT / config.FEEDBACK_LOG_FILE}")

    # Verify content of the log file (basic check)
    try:
        with open(config.PROJECT_ROOT / config.FEEDBACK_LOG_FILE, 'r') as f:
            lines = f.readlines()
        assert len(lines) == 4 # 3 log_interaction calls + 1 info message from setup
        logger.info(f"Log file contains {len(lines)} lines as expected (including setup info).")

        # Check if the first actual log entry (second line) is valid JSON and contains expected keys
        first_log_entry_json = lines[1].strip() # First line is often the "initialized" message
        if len(lines) > 1 else None

        if first_log_entry_json:
            try:
                first_log_data = json.loads(first_log_entry_json)
                assert "session_id" in first_log_data
                assert first_log_data["session_id"] == "session_001"
                assert "user_query" in first_log_data
                assert "feedback" in first_log_data and "was_helpful" in first_log_data["feedback"]
                logger.info("First log entry successfully parsed as JSON and contains expected keys.")
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse log entry as JSON: {e}. Entry: {first_log_entry_json}")
            except AssertionError as e:
                logger.error(f"Assertion failed for log entry content: {e}. Entry: {first_log_data}")
        else:
            logger.warning("Log file seems to have less than 2 lines, cannot verify first log entry content.")

    except FileNotFoundError:
        logger.error(f"Log file not found at {config.PROJECT_ROOT / config.FEEDBACK_LOG_FILE}. Logging might have failed.")
    except Exception as e:
        logger.error(f"An error occurred during log file verification: {e}", exc_info=True)

    logger.info("--- Feedback Logger tests complete ---")

```
